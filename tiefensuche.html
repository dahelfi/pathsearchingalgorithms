<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <script>
    function depthFirstSearch() {
      let graph = [
        [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0],
        [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
        [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],
        [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
      ];
      root = 6;
      let nodes = {}; //wird benutzt um die Distanzen zu speichern

      for (let i = 0; i < graph.length; i++) {
        //intialisierung von jeden spÃ¤teren ausgabe wert mit null
        nodes[i] = {
          node: String.fromCharCode(i + 65),
          discoveryTime: null,
          finishingTime: null,
          index: i,
        };
      }
      stepsCounter = 0;
      let queue = [nodes[root].index];

      while (queue.length != 0) {
        console.log("hier die queue: ", queue);
        let checkIfNodeFinished = true;
        let startWhileLoop = true;
        let current = queue[0];
        if (nodes[current].discoveryTime === null) {
          nodes[current].discoveryTime = stepsCounter++;
        }

        let currrentNode = graph[current];
        let connectedNodeNumber = currrentNode.indexOf(1);

        while (connectedNodeNumber != -1 && startWhileLoop) {
          //erzeugen von einem Array mit Knoten die mit dem aktuellen Knoten verbunden sind
          if (nodes[connectedNodeNumber].discoveryTime === null) {
            queue.unshift(nodes[connectedNodeNumber].index);
            startWhileLoop = false;
            checkIfNodeFinished = false;
          }
          connectedNodeNumber = currrentNode.indexOf(
            1,
            connectedNodeNumber + 1
          );
        }

        if (checkIfNodeFinished) {
          nodes[current].finishingTime = stepsCounter++;
          queue.splice(0, 1);
        }

       
      }
      console.log("here your solution: ",nodes)
    }

    let graph2 = [
      [0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 1, 0, 0],
      [0, 1, 0, 0, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 1],
      [0, 1, 0, 1, 0, 1, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [0, 0, 0, 1, 0, 0, 0],
    ];

    let graphYT = [
      [0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 1, 0, 0],
      [0, 1, 0, 0, 0, 1, 0],
      [0, 0, 0, 0, 1, 0, 1],
      [0, 1, 0, 1, 0, 1, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [0, 0, 0, 1, 0, 0, 0],
    ];

    let BFSGraph = [
      [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
      [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0],
      [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
      [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
      [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1],
      [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
    ];

    let testGraph = [
      [0, 1, 0, 1, 0, 0],
      [0, 0, 0, 0, 1, 0],
      [0, 0, 0, 0, 1, 1],
      [0, 1, 0, 0, 0, 0],
      [0, 0, 0, 1, 0, 0],
      [0, 0, 0, 0, 0, 1],
    ];

    let BFSGraphShort = [
      [0, 1, 1, 1, 0],
      [0, 0, 1, 0, 0],
      [1, 1, 0, 0, 0],
      [0, 0, 0, 1, 0],
      [0, 1, 0, 0, 0],
    ];
  </script>
  <body></body>
</html>
